<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- The above 3 meta tags *must* come first in the head; any other head content must come *after* these tags -->
    <meta name="description" content="Home">
    <meta name="author" content="Kolton Benoit">
    <link rel="icon" href="">

    <title>Lab 4</title>

    <!-- Latest compiled and minified CSS -->
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">

    <!-- Optional theme -->
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap-theme.min.css" integrity="sha384-rHyoN1iRsVXV4nD0JutlnGaslCJuC7uwjduW9SVrLvRYooPp2bWYgmgJQIXwl/Sp" crossorigin="anonymous">

    <!-- Latest compiled and minified JavaScript -->
    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script>

    <!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
      <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
    
    <!--highlight.js for code highlighting-->
	<link rel="stylesheet" href="/styles/ir-black.css">
	<script src="/highlight.pack.js"></script>
	<script>hljs.initHighlightingOnLoad();</script>
  </head>

  <body>

    <!-- Fixed navbar -->
    <nav class="navbar navbar-inverse navbar-fixed-top">
      <div class="container">
        <div class="navbar-header">
          <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <a class="navbar-brand" href="../index.html">Polytech Pi Labs</a>
        </div>
        <div id="navbar" class="navbar-collapse collapse">
          <ul class="nav navbar-nav">
            <li class="active"><a href="../index.html">Home</a></li>
        </div><!--/.nav-collapse -->
      </div>
    </nav>
    
    <div class="container theme-showcase" role="main">

      <!-- Main jumbotron for a primary marketing message or call to action -->
      <div class="jumbotron">
        <h1>Lab 4: </h1>
        <h2>Using a shift register</h2>
        
        <h3>Information</h3>
        In the last lab, you used the Raspberry Pi's General Purpose Input/Output pins for both input and output. For input, your code checked to see if any of 4 buttons were pressed. For output, your code turned on up to 8 LEDs. Each of these buttons and LEDs are connected to an individual GPIO pin. However, direct connections like this are actually an inefficient method of connecting devices to the Pi. Why? Look at this pin diagram from <a href="https://pinout.xyz">pinout.xyz</a>:
        <img src="https://pinout.xyz/resources/raspberry-pi-pinout.png">
        Some of these pins have special functions that others do not have:
        <ul>
            <li><a href="https://en.wikipedia.org/wiki/Universal_asynchronous_receiver/transmitter">UART</a></li>
            <ul>
                <li>Universal Asynchronous Receiver/Transmitter. The old school way of communicating to other devices. With the right adapter, it can connect to RS-232 devices that can either access the PI's console or allow the PI to access the console of, say, a Cisco switch.</li>
                <li>BCM 14 is the UART Tx line</li>
                <li>BCM 15 is the UART Rx line</li>
            </ul>
            <li><a href="https://en.wikipedia.org/wiki/I%C2%B2C">I²C</a></li>
            <ul>
                <li>Inter-Intergrated Circuit, which is supposed to be written as I²C, but is often written as I2C since super scripts are too hard. The abbrivation is actually pronounced as "I-squared-C" so don't call it "I-two-C" if you don't want to be made fun of behind your back! The PI has two I²C channels 0 and 1.</li>
                <li>BCM 2 is the Serial Data line (SDA) for channel 1</li>
                <li>BCM 3 is the Serial Clock line (SCL) for channel 1</li>
                <li>BCM 0 is the Serial Data line (SDA) for channel 0</li>
                <li>BCM 1 is the Serial Clock line (SCL) for channel 0</li>
                <li><i>Note:</i> The HAT breaks out the I²C channel 1 lines, but the channel 0 lines are connected to the EEPROM chip below the buttons, next to the camera slot.</li>
            </ul>
            <li><a href="https://en.wikipedia.org/wiki/Serial_Peripheral_Interface_Bus">SPI</a></li>
            <ul>
                <li>Serial Peripheral Interface. The PI has two SPI channels 0 and 1, but you have to chose your own chip select pin for channel 1.</li>
                <li>BCM 10 is the Master Out Slave In (MOSI) line for channel 0</li>
                <li>BCM 9 is the Master In Slave Out (MISO) line for channel 0</li>
                <li>BCM 10 is the Serial Clock (SCLK) line for channel 0</li>
                <li>BCM 8 is the Chip Enable 0 (CE0) line for channel 0</li>
                <li>BCM 7 is the Chip Enable 1 (CE1) line for channel 0</li>
                <li>BCM 20 is the Master Out Slave In (MOSI) line for channel 1</li>
                <li>BCM 19 is the Master In Slave Out (MISO) line for channel 1</li>
                <li>BCM 21 is the Serial Clock (SCLK) line for channel 1</li>
                <li><i>Note:</i> Can use another GPIO pin as another Chip Enable pin, but your code has to be written a little differently.</li>
                <li><i>Note:</i> The HAT only breaks out the channel 0 pins. Channel 1 MOSI is used for Switch 2, Channel 1 SCLK is used for Switch 3, and Channel 1 MISO is used for LED2.</li>
            </ul>
            <li><a href="https://en.wikipedia.org/wiki/1-Wire">1-Wire</a></li>
            <ul>
                <li>The 1-Wire interface uses 1 wire for communication, if that wasn't obvious.</li>
                <li>BCM 4 is the Data line.</li>
            </ul>
        </ul>
        
        The HAT was designed to breakout these special connections so that <i>someone</i> (hint, hint) could more easily use them to extend the functionality of the HAT and build a neat project. These special lines can also be used as normal GPIO pins, but access to that special feature is lost. Because we're saving those pins for their special use, there aren't a lot of options to add more functionality to the HAT. So, how many pins do we still have to work with? We know that the PI 2 (and newer) has 40 pins. Let's count the specialized pins, pins for the LEDs, pins for the buttons, pins for power and ground:
        <ul>
            <li>8 LEDs</li>
            <li>4 Buttons</li>
            <li>2 UART lines</li>
            <li>4 I²C lines (2 channels)</li>
            <li>5 SPI lines (channel 0 only, remember that the channel 1 pins were used for buttons or LEDs)</li>
            <li>1 1-Wire line</li>
            <li>2 5 volt power lines</li>
            <li>2 3.3 volt power lines</li>
            <li>8 Ground lines</li>
        </ul>
        So, do some fifth grade math and figure out how many pins are left. Alright, fine, <a href="http://lmgtfy.com/?q=40+-+(8%2B4%2B2%2B4%2B5%2B1%2B2%2B2%2B8)">I'll do it for you</a>: there are 4 pins available.</br></br>
        
        Now, look at your HAT. Look at the 7 segment display. How many LEDs in the display are there? 8: the 7 segments of the digit and the decimal point. We only have 4 pins to drive 8 LEDs. How would we accomplish this? We use a shift register!</br></br>
        
        <i>What's a shift register?</i></br>
        It is a register that you shift bits into!</br></br>
        
        Alright, fine a more detailed explanation: a shift register is an integrated circuit that allows a microcontroller or other device to expand input or output by reading or writing data in serial. They outputting data one bit at a time, storing it in a register, and shifting the values in the register over.</br></br>
        
        The HAT uses a <code>74HC595N</code> shift register, the black package next to the seven segment display. It requires at least 3 lines to drive: <code>data</code>, <code>clock</code>, and <code>latch</code>. There are an optional 2 lines that can be used: <code>output enable</code> and <code>clear register</code>. If these aren't used, tie <code>output enable</code> to ground and <code>clear register</code> to 5v. It can be daisy chained to more shift registers, allowing for an arbitrary number of extra pins. The HAT doesn't use the two optional lines, since we only have 4 pins available and it would be more complicated to program. Review the schematic for the 7 segment display functional area of the HAT:
        <img src="../images/4/sch.1.png"></br>
        
        <h3>Instructions</h3>
        <ol>
            <li>Download the <code>7seg.py</code> code from the Resources section. Run it and use <kbd>ctrl</kbd>+<kbd>c</kbd> when you're ready for the next step.</li>
            <li>Open the code in <code>nano</code> to analyze it.</li> 
            <ul>
                <li>The shift register only needs 3 pins: <code>data</code>, <code>clock</code>, and <code>latch</code>. We'll use BCM 17 for <code>data</code>, BCM 27 for <code>clock</code>, and BCM 22 for <code>latch</code>.</li>
                <pre><code class="python">#Pins for shift register
dataPin = 17
clockPin = 27
latchPin = 22</code></pre>
                <li>Next is an array full of hexidecimal values. We use this so that we can just call <code>segments[]</code> to display a certain digit on the 7 segment display and not need to remember what bits need to be shifted out to the register.</li>
                <li>But, how do we know which values will display which character? Simple: the schematic and binary. Take a look at the schematic again, specifically the following part:</li>
                <img src="../images/4/sch.2.png">
                <li>According to the schematic above, the following pins on the shift register map to the LEDs in the seven segment display:</li>
                <table class ="table table-bordered" style="width:100%">
                    <tr>
                        <td><b>Shift register pin</b></td>
                        <td>QA</td>
                        <td>QB</td>
                        <td>QC</td>
                        <td>QD</td>
                        <td>QE</td>
                        <td>QF</td>
                        <td>QG</td>
                        <td>QH</td>
                    </tr>
                    <tr>
                        <td><b>Segment</b></td>
                        <td>a</td>
                        <td>b</td>
                        <td>c</td>
                        <td>d</td>
                        <td>e</td>
                        <td>f</td>
                        <td>g</td>
                        <td>DP</td>
                    </tr>
                </table>
                <li>With the above chart, we know which shift register pins we need to turn on to turn on a given display segment. Next, we need to know which <i>segments</i> we need to turn on to show the digit we want. To do that, let's work out how to display the character <code>0</code>. We'll use <code>0</code> to represent <code>OFF</code> and <code>1</code> to represent <code>ON</code>:</li>
                <table class ="table table-bordered" style="width:100%">
                    <tr>
                        <th rowspan="3"><img src="../images/4/sch.3.png"></th>
                        <td><b>Shift register pin</b></td>
                        <td>QA</td>
                        <td>QB</td>
                        <td>QC</td>
                        <td>QD</td>
                        <td>QE</td>
                        <td>QF</td>
                        <td>QG</td>
                        <td>QH</td>
                    </tr>
                    <tr>
                        <td><b>Segment</b></td>
                        <td>a</td>
                        <td>b</td>
                        <td>c</td>
                        <td>d</td>
                        <td>e</td>
                        <td>f</td>
                        <td>g</td>
                        <td>DP</td>
                    </tr>
                    <tr>
                        <td><b>Is On:</b></td>
                        <td>1</td>
                        <td>1</td>
                        <td>1</td>
                        <td>1</td>
                        <td>1</td>
                        <td>1</td>
                        <td>0</td>
                        <td>0</td>
                    </tr>
                </table>
                <li>Now we know what the binary value is that represents the <code>0</code> character, but binary is a little inconvenient to type and is easy to make a mistake, so let's convert it to decimal. To convert binary to decimal, we take the decimal value of each binary position and add the values of positions with a <code>1</code>:</li>
                <table class ="table table-bordered" style="width:100%">
                    <tr>
                        <th rowspan="4"><img src="../images/4/sch.3.png"></th>
                        <td><b>Shift register pin</b></td>
                        <td>QA</td>
                        <td>QB</td>
                        <td>QC</td>
                        <td>QD</td>
                        <td>QE</td>
                        <td>QF</td>
                        <td>QG</td>
                        <td>QH</td>
                    </tr>
                    <tr>
                        <td><b>Segment</b></td>
                        <td>a</td>
                        <td>b</td>
                        <td>c</td>
                        <td>d</td>
                        <td>e</td>
                        <td>f</td>
                        <td>g</td>
                        <td>DP</td>
                    </tr>
                    <tr>
                        <td><b>Is On:</b></td>
                        <td>1</td>
                        <td>1</td>
                        <td>1</td>
                        <td>1</td>
                        <td>1</td>
                        <td>1</td>
                        <td>0</td>
                        <td>0</td>
                    </tr>
                    <tr>
                        <td><b>Decimal value: (add if bold)</b></td>
                        <td><b>128</b></td>
                        <td><b>64</b></td>
                        <td><b>32</b></td>
                        <td><b>16</b></td>
                        <td><b>8</b></td>
                        <td><b>4</b></td>
                        <td>2</td>
                        <td>1</td>
                    </tr>
                </table>
                <li>So, what's 128+64+32+16+8+4? <a href="http://lmgtfy.com/?q=128%2B64%2B32%2B16%2B8%2B4">252</a>!</li>
                <li>Decimal is great and all, but sometimes even decimal numbers start to get out of hand, so let's convert our binary number into a hexidecimal number by using the following chart:</li>
                <table class ="table table-bordered" style="width:100%">
                    <tr>
                        <td><b>Binary</b></td>
                        <td>0000</td>
                        <td>0001</td>
                        <td>0010</td>
                        <td>0011</td>
                        <td>0100</td>
                        <td>0101</td>
                        <td>0110</td>
                        <td>0111</td>
                        <td>1000</td>
                        <td>1001</td>
                        <td>1010</td>
                        <td>1011</td>
                        <td>1100</td>
                        <td>1101</td>
                        <td>1110</td>
                        <td>1111</td>
                    </tr>
                    <tr>
                        <td><b>Hexidecimal</b></td>
                        <td>0</td>
                        <td>1</td>
                        <td>2</td>
                        <td>3</td>
                        <td>4</td>
                        <td>5</td>
                        <td>6</td>
                        <td>7</td>
                        <td>8</td>
                        <td>9</td>
                        <td>A</td>
                        <td>B</td>
                        <td>C</td>
                        <td>D</td>
                        <td>E</td>
                        <td>F</td>
                    </tr>
                </table>
                <table class ="table table-bordered" style="width:100%">
                    <tr>
                        <td><b>Binary value to change:</b></td>
                        <td>1111</td>
                        <td>1100</td>
                    </tr>
                    <tr>
                        <td><b>Hexidecimal value:</b></td>
                        <td>F</td>
                        <td>C</td>
                    </tr>
                    <tr>
                        <td><b>Full hexidecimal value:</b></td>
                        <td>0xFC</td>
                    </tr>
                </table>
                <li>Now we have the hexidecimal value of <code>FC</code>, but we'll want to write it as <code>0xFC</code>. The <code>0x</code> makes sure that we don't mistake a hexidecimal value for a decimal value.</li>
                <li>Now, look at your code, at the first value in the array created:</li>
                <pre><code class="python">segments = [0xFC, 0x60, 0xDA, 0xF2, 0x66, 0xB6, 0x3E, 0xE0, 0xFE, 0xF6]</code></pre>
                <li>See the <code>0xFC</code>? Looks familar, doesn't it? Try doing the process we just did to find out what the rest of the values will display.</li>
                <pre><code class="python"></code></pre>
                <li></li>
                <pre><code class="python"></code></pre>
            </ul>
        </ol>
        
        <h3>Resources</h3>
        Download these files to your Raspberry Pi:
        <ol>
            <li><a href="../4/7seg.py">7seg.py</a></li>
        </ol>
      </div>
      
    </div> <!-- /container -->

  </body>
</html>
